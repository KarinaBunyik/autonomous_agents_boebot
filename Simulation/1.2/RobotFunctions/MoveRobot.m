function r = MoveRobot(robot,dt);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Equations of motion:
%%
%% M*vDot + alpha*v = A(tL + tR)
%% I*phiDotDot + beta*phiot = B(-tL + tR);
%%
%% Torques: tau(1) = left, tau(2) = right.
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

oldPosition = [robot.Position(1)  robot.Position(2)];
oldSpeed = robot.Speed;
oldHeading = robot.Heading;
oldAngularSpeed = robot.AngularSpeed;

r = robot;

r.OldPosition = oldPosition;
r.OldHeading = oldHeading;

%% Motor signals (in [-1,1]) generated by the brain of the robot:
s = GetMotorSignalsFromBrain(r.Brain);

%% Scale signals to obtain voltages.
v = ScaleMotorSignals(r,s);

r.Motors(1) = GetTorque(r.Motors(1),v(1));
r.Motors(2) = GetTorque(r.Motors(2),v(2));
tau = [r.Motors(1).Torque, r.Motors(2).Torque];
tau_r = tau(1) + tau(2);
tau_phi = -tau(1) + tau(2);

vDot = (-r.Alpha*oldSpeed + r.A*tau_r)/r.Mass;
phiDotDot = (-r.Beta*oldAngularSpeed + r.B*tau_phi)/r.MomentOfInertia;

v = oldSpeed + vDot*dt;
r.Speed = v;
r.AngularSpeed = oldAngularSpeed + phiDotDot*dt;

r.Heading = oldHeading + r.AngularSpeed*dt;

if (r.Heading > pi) 
 r.Heading = r.Heading - 2*pi;
elseif (r.Heading < -pi)
 r.Heading = r.Heading + 2*pi;
end

r.Velocity(1) = v*cos(r.Heading);
r.Velocity(2) = v*sin(r.Heading);
r.Position(1) = oldPosition(1) + v*cos(r.Heading)*dt;
r.Position(2) = oldPosition(2) + v*sin(r.Heading)*dt;

r = UpdateMotorAxisAngularSpeed(r);
r.Sensors = UpdateSensorPositions(r);

